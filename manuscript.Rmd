---
title: 'Memes: an R interface to the MEME Suite'
author:
- ORCID: 0000-0003-1000-1579
  name: Spencer L. Nystrom
- name: Daniel J. McKay
output: 
 - word_document
---

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
# Figure caption: https://stackoverflow.com/questions/31926623/figures-captions-and-labels-in-knitr
suppressPackageStartupMessages(library(memes))
suppressPackageStartupMessages(library(magrittr))
suppressPackageStartupMessages(library(GenomicRanges))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ComplexHeatmap))
drake::r_make()
```

# Abstract

Biopolymers, such as DNA and protein molecules, perform varying functions based on their
primary sequence. Short, repeated sequences, or "motifs" represent functional
units within biopolymers that can act as interaction surfaces, create
structure, or have enzymatic activity. Identification of shared motifs across
multiple sequences can provide evidence for shared function. Thus, the ability to
identify, classify, and compare motifs represents a key step in the analysis of
biological sequences. **TODO: Transition sentence RE: R/motifs** Although tools
implementing these features exist within Bioconductor, they often rely on
proprietary data types with poor interoperability with other tools. **TODO: remove this sentence?** Furthermore,
several of these packages will be deprecated in the next Bioconductor release,
leaving a gap in functionality with no clear alternatives.

The MEME Suite is a series of commandline tools that provide a variety of
features for motif analysis including *de-novo* motif discovery, enrichment
testing, comparison, and matching. Here we present `memes`, a motif analysis
package that provides a seamless interface to MEME Suite tools within R.

`memes` uses standard R and Bioconductor data types for better integration with
common analysis tools like the `tidyverse` and `GRanges`. `memes` outputs also
function as inputs to other `memes` commands, allowing simple construction of motif
analysis pipelines.

In addition to wrapping MEME Suite utilities, `memes` extends the functionality
of `universalmotif` to provide base R and `tidyverse` compatible syntax for
manipulating and analyzing motif metadata. These features allow motif databases
to integrate external data to aid analysis, such as filtering a set of
transcription factor motifs based on gene expression. Lastly, `memes` also provides
simple utilities for data visualization.

`memes` is designed for maximum flexibility and ease of use to allow rapid
iteration during analysis. Here we present several examples of how `memes`
allows novel analyses of ChIP-seq and FAIRE-seq data by facilitating seamless
interoperability between MEME Suite tools and the broader R landscape.


# Introduction

Biopolymers, such as DNA and protein, perform varying functions based on their
primary sequence. Short, repeated sequences, or "motifs" represent functional
units within biopolymers which can act as interaction surfaces, create
structure, or have enzymatic activity. Identification of shared motifs across
multiple sequences can provide evidence for shared function, for example,
identification of kinase substrates based on similarities in phosphorylation
site sequence, or characterizing DNA elements based on shared transcription
factor binding sequences (TODO: ref kinase motif:
https://doi.org/10.1016/0968-0004(90)90073-K). Thus the ability to
identify, classify, and compare motifs represents a key step in the analysis of
biological sequences. **TODO: R/Bioconductor transition sentence**. Although
tools that implement these features have historically existed in the
Bioconductor landscape, they often rely on proprietary data types with poor
interoperability with other tools, creating barriers to comprehensive motif
analysis within R. 
**TODO: fix this section, how to transition?**
Furthermore, popular motif analysis packages, MotIV, and motifRG 
will be deprecated in the next Bioconductor release,
leaving a gap in functionality with no clear alternatives.

The MEME Suite is a series of commandline and web-based tools that provide a variety
of features for motif analysis such as *de-novo* motif discovery, enrichment
testing, comparison, and matching \cite{meme-suite}. The MEME Suite is a widely
utilized set of tools, with over 22,000 citations to date, and greater than 30,000 unique
users of the webserver implementation annually \cite{meme-usage-report-page,
google-scholar-meme}. The MEME Suite family of tools provides a comprehensive
set of utilities to interrogate motif content across a broad range of biological
contexts. However, several factors limit the full potential of these tools for
use in data analysis. MEME Suite tools require carefully formatted inputs to
achieve full functionality, yet few tools exist to simplify the process of data
formatting, requiring instead that users write custom code to prepare their
data, or prepare the inputs by hand, both of which have the potential to be
error prone without rigorous testing. Furthermore, the output data from each
MEME Suite tool often have complex structures that must be parsed to extract the
full suite of information, again requiring users to write custom code for this
task. Finally, although the data-generation capabilities of the MEME Suite are
excellent, the tools lack powerful ways to visualize the results. Collectively,
these factors act as barriers to adoption and preclude deep analysis of the
data, as well as communication of results to the scientific community. 

Here we present `memes`, a motif analysis package that provides a seamless
interface to MEME Suite tools within R. `memes` uses base R and Bioconductor
data types for data input and output, facilitating better integration with
common analysis tools like the `tidyverse` and other Bioconductor packages.
Unlike the commandline implementation, `memes` outputs also function as inputs
to other MEME Suite tools, allowing simple construction of motif analysis
pipelines without additional data processing steps. Additionally, R/Bioconductor
data structures provide a full-featured representation of MEME Suite output
data, providing users quick access to all relevant data structures with simple
syntax. **TODO: Depending on length restrictions, end here**

In addition to wrapping MEME Suite utilities, `memes` extends the functionality
of `universalmotif` to provide base R and `tidyverse` compatible syntax for
manipulating and analyzing motif metadata. These features allow users to
integrate external data with motif databases to aid analysis, such as filtering
a set of transcription factor motifs based on gene expression in the tissue of
interest, then using that filtered set to search for motifs associated with
expressed factors.

`memes` also provides simple utilities for data visualization where appropriate.
Providing R representations of MEME Suite data objects enables generation of
novel data visualizations using the well established tools available in the R
landscape. Therefore, `memes` empowers users to deeply analyze and visualize
motif analysis data.

`memes` is designed for maximum flexibility and ease of use to allow users to
iterate rapidly during analysis. Here we present several examples of how `memes`
allows novel analyses of ChIP-seq and FAIRE-seq data by facilitating seamless
interoperability between MEME Suite tools and the broader R package landscape.

## Design & Implementation

### Core Utilities

MEME Suite tools are run on the commandline and use files stored on-disk as
input while returning a series of output files containing varying data types. 
As a wrapper of MEME tools, `memes` functions similarly by assigning each
supported MEME Suite tool to a `run` function (`runDreme()`,
`runMeme()`, `runAme()`, `runFimo()`, `runTomTom()`), which
internally writes input objects to files on disk, runs the tool, then imports
the data as R objects. These functions accept sequence and motif inputs as
required by the tool. Sequence inputs are accepted in `BioStrings` format, an
R/Bioconductor package for storing biopolymer sequence data \cite{BioStrings}.
Motif inputs are passed as `universalmotif` objects, another R/Bioconductor
package for representing motif matrices and their associated metadata
\cite{universalmotif}. `memes` `run` functions will also accept paths to files
on disk, such as fasta files for sequence inputs, and meme format files for
motif inputs, reducing the need to read large files into memory. Finally, each
`run` function contains optional function parameters mirroring the commandline
arguments provided by each MEME Suite tool. In this way, `memes` provides a
feature-complete interface to the supported MEME Suite tools.

### Output Data Structures

MEME tools return HTML reports for each tool that display data in a
user-friendly way, however, these files are not ideal for downstream processing.
Depending on the tool, data are also returned in tab-separated, or XML format,
which are more amenable to computational processing. However, in the case that
tab-separated data are returned, results are often incomplete. For example, the
TomTom tool, which compares query motifs to a database of known motifs, returns
tab-separated results that do not contain the frequency matrix representations
of the matched motifs. Instead, users must write custom code to parse these
matrices back out from the input databases, creating additional barriers to
analysis. In the case that data are returned in XML format, these files contain
all relevant data, however are difficult to parse, again requiring users to
write custom code to extract the necessary data. Finally, the data types
contained in MEME Suite outputs are complex and multidimensional, and thus
require special data structures to properly organize the data in memory.

`memes` provides data import functions for each supported MEME Suite tool, which
import these data as modified R data.frames (described in detail below). These
functions can be called directly by users to import data previously generated by
the commandline or webserver versions of the MEME Suite for use in R. These
import functions also underlie the import step internal to each of the `run`
functions.

### structured data.frames hold multidimensional output data

 - as mentioned previously, the multidimensional naature of meme results is difficult to represent
 - Output data usually contain motifs & descriptive statistics about those motifs
 - motif info can be stored in universalmotif format, however, not enough space for data
 - data.frames do good job of storing data (incl nested data), but cannot store motifs
 - we solve this problem by storing the unviversalmotif inside the data.frame (which is valid R)
 - we add nested list columns as needed to link multidimensional data
 - advantage of this approach over an S4 is all normal tools work on it (tidyverse), joins, etc.

Many of the MEME Suite tools return files contianing descriptive
properties of motifs. For example, MEME and DREME return de-novo discovered
motifs from query sequences along with statistical information about their
enrichment. The `universalmotif` data structure is a powerful R/Bioconductor
representation for motif matrices and their associated metadata
\cite{universalmotif}.  However, `universalmotif` objects are not ideal for
performing bulk manipulation or queries of metadata, nor do they support complex
data structures such as nested elements. Many MEME Suite analysis pipelines
involve identifying motifs which are further analyzed by multiple tools,
creating additional metadata which cannot be easily tracked in bulk using
`universalmotif` format. Thus an ideal representation for these data is one
which can hold an unlimited amount of metadata, contain complex hierarchies, and
be easily manipulated using standard analysis tools. `memes` therefore extends
the `universalmotif` format by providing data.frames holding motif metadata
which retain links to their `universalmotif` representation. These
universalmotif data.frames combine the advantages of the `universalmotif`
framework for motif manipulation with the extensibility and flexibility of R
data.frames. These `universalmotif` data.frames form the basis for a majority of
`memes` data outputs. These structures are also valid input types to `memes`
functions, and when used as such, output data are appended as new columns to the
input data, ensuring data provenance.

**Figure?: showing how the data.frame connects to universalmotif**

`universalmotif` data.frames are not limited to storing motifs from MEME Suite
data, and can additionally be used to examine or manipulate the properties of
any motif list or database. Using `universalmotif` functions to import motif data,
the `memes` function `as_universalmotif_dataframe()` converts any `universalmotif` object
into a `universalmotif` data.frame which can be manipulated using base R or
`tidyverse` functions, just like regular R data.frames. Manipulation of linked
metadata columns will result in updating the linked `universalmotif` object when
calling `update_motifs()` to retain the data.frame structure, or when calling
`as_universalmotif()` to convert the data.frame back into `universalmotif` format. In
this way, `memes` enables large-scale motif database manipulation & analysis
within the preexisting R framework.

### Support for genomic range-based data

Motif analysis is often employed in ChIP-seq analysis, in which data is stored
as genomic coordinates rather than sequence. However, MEME Suite tools are
designed to work with sequences. While existing tools such as bedtools can
extract DNA sequence from gneomic coordinates, some MEME tools require fasta
headers to be specifically formatted. As a result, users must write custom code
to extracd DNA sequence for their genomic ranges of interest. 

The `memes` function `get_sequence` automates extraction of
DNA sequence from genomic coordinates while simultaneously producing MEME Suite
formatted fasta headers. `get_sequence` accepts genomic-range based inputs in
`GenomicRanges` format, the *de-facto* standard for genomic coordinate
representation in R \cite{genomicranges}. Other common genomic coordinate
representations, such as bed format, are easily imported as `GenomicRanges`
objects into R using preexisting import functions, meaning `memes` users do not
have to write any custom import functions to work with range-based data using
`memes`.  Sequences are returned in `Biostrings` format and can therefore be
used as inputs to all `memes` commands or as inputs to other R/Bioconductor
functions for sequence analysis. 

During analysis of multiomic data, users can identify different functional
categories of genomic regions through integration with orthogonal datasets. **TODO
For example, .** 

In these instances, motif analysis acts as a powerful tool to
examine whether differences in motif content is associated with membership of
distinct categories. In some cases, performing differential motif analysis
(using one category as the "test" set and another as the "control") can uncover
biologically relevant motifs which are enriched in one category relative to
another. Although the MEME Suite allows differential enrichment testing, it does
not inherently provide a mechanism for analyzing groups of sequences in
parallel, or performing motif analysis with any understanding of data
categories. The `memes` framework enables "data-aware" motif analysis workflows
by allowing named lists of `Biostrings` objects as input to each function. If
using `GenomicRanges`, users can split peak data on a metadata column using the
base R `split` function, and then use this result as input to `get_sequence`, which
will produce a list of `BioStrings` objects where each entry is named after the
data categories from the split column. When a list is used as input to a `memes`
function, it runs the corresponding MEME Suite tool for each object in the list.
Users can also pass the name(s) of a category to the `control` argument to
enable differential analysis of the remaining list members against the
control category sequences. Therefore, `memes` enables complex data-aware
differential motif analysis workflows using simple syntax to extend the
capabilities of the MEME Suite.

## Data visualization
The MEME Suite provides a small set of data visualizations that have limited
customizability. `memes` leverages the advantages of the R graphics environment
to provide a wide range of data visualization options that are highly
customizable. We describe two scenarios below.

The TomTom tool allows users to compare unknown motifs to a set of known motifs
to identify the best match. Visual inspection of motif comparison data is a key
step in assessing the quality and accuracy of a match. The `view_tomtom_hits`
function allows users to compare query motifs with the list of potential matches
as assigned by TomTom. The `force_best_match` function allows users to
reassign the TomTom best match to a lower-ranked (but still statistically
significant) match in order to highlight motifs with greater biological
relevance (e.g. to skip over a transcription factor that is not expressed in the
experimental sample, or when two motifs are matched equally well).

The AME tool searches for enrichment of motifs within a set of experimental
sequences relative to a control set. The meaningful result from this tool is the
statistical parameter (for example, a p-value) associated with the significance
of motif enrichment. However, AME does not provide a mechanism for visualizing
these results. 

The `ame_plot_heatmap` function in `memes` returns a `ggplot2` formatted heatmap of
statistical significance of motif enrichment. If AME is used to examine motif
content of multiple groups of sequences, the `ame_plot_heatmap` function can also
return a plot comparing motif significance within multiple groups. Several
options exist to customize the heatmap values in order to capture different aspects
of the output data. The `ame_compare_heatmap_methods()` function enables users
to compare the distribution of values between samples in order to select a
threshold that accurately captures the dynamic range of their results.

## Containerized analysis maximizes availability and facilitates reproducibility
`memes` relies on a locally installed version of the MEME Suite which is
accessed by the user's R process. Although R is available on Windows, Mac, and
Linux operating systems, the MEME Suite is incompatible with Windows, limiting
its adoption by Windows users. Additional barriers also exist to installing a
local copy of the MEME Suite on compatible systems, for example, the MEME Suite
relies on several system-level dependencies whose installation can be difficult
for novice users. Finally, some tools in the MEME Suite use python to generate
shuffled control sequences for analysis, which presents a reproducibility issue
as the random number generation algorithm changed between python2.7 and python3. The
MEME Suite will build and install on both python2.7 and python3 systems,
therefore without careful consideration of this behavior, the same code run on
two systems may not produce identical results, even if using the same major
version of the MEME Suite. In order to increase access to the MEME Suite on
unsupported operating systems, and to facilitate reproducible motif analysis
using `memes`, we have also developed docker and singularity (**TODO: NOTE:**
singularity is broken for `rocker/rstudio`, so maybe omit this until fixed)
containers containing a preinstalled version of the MEME Suite along with an
R/Bioconductor analysis environment including the most recent version of `memes`
and its dependencies.  As new container versions are released, they are
version-tagged and stored to ensure reproducibility while allowing updates to
the container.

# Results

Here we briefly highlight each of `memes` current features for analyzing
ChIP-seq data. Additional detailed walkthroughs for each supported MEME Suite
tool, and a complete worked example using `memes` to analyze ChIP-seq data can be found
in the `memes` vignettes and the package website
([snystrom.github.io/memes](snystrom.github.io/memes)). In the following
example, we reanalyze recent work examining the causal relationship between the
binding of the transcription factor E93 to changes in chromatin accessibility
during *Drosophila* wing development \cite{Nystrom, Niederhuber 2020}. Here, we
utilize ChIP-seq peak calls for E93 which have been annotated according to the
change in chromatin accessibility observed before & after E93 binding. These
data are an idiomatic example of range-based genomic data (E93 ChIP peaks)
containing additional groupings (the chromatin accessibility response following
DNA binding) whose membership may be influenced by differential motif content.
We show how `memes` syntax allows complex analysis designs, how `memes`
utilities enable deep interrogation of results, and how `memes` flexible data
structures empower users to integrate the `memes` workflow with tools offered by
other R/Bioconductor packages.


```{r, echo = F}
drake::loadd(chip_results)
```

The aforementioned ChIP-seq peaks are stored as a GRanges object with a metadata
column (`e93_chromatin_response`) indicating whether chromatin accessibility
tends to increase ("Increasing"), decrease ("Decreasing"), or remain unchanged
("Static") following E93 binding.
```{r}
head(chip_results, 3)
```

Using the `get_sequence` function, GRanges objects are converted into
DNAStringSet outputs.
```{r}
dm.genome <- BSgenome.Dmelanogaster.UCSC.dm3::BSgenome.Dmelanogaster.UCSC.dm3

all_sequences <- chip_results %>% 
  get_sequence(dm.genome)
```

```{r}
head(all_sequences)
```
In order to perform analysis within different groups of peaks, the GRanges object can be `split` on a metadata column before input to `get_sequence`.
```{r}
sequences_by_response <- chip_results %>% 
  split(mcols(.)$e93_chromatin_response) %>% 
  get_sequence(dm.genome)

```

This produces in a BStringSetList where list members contain a DNAStringSet for each group of sequences.
```{r}
head(sequences_by_response)
```

## Denovo motif analysis
The DREME tool can be used to discover short, novel motifs present in a set of
input sequences relative to a control set. The `runDreme` command is the `memes`
interface to the DREME tool. `runDreme` syntax enables users to produce complex
discriminative analysis designs using intuitive syntax. Examples of possible
designs and their syntax are compared below.

```{r, eval=F}
# use all sequences vs shuffled background
runDreme(all_sequences, control = "shuffle")

# for each response category, discover motifs against a shuffled background set
# Produces:
#  - Increasing vs Shuffled Increasing
#  - Decreasing vs Shuffled Decreasing
#  - Static vs Shuffled Static
runDreme(sequences_by_response, control = "shuffle")

# Search for motifs enriched in the "Increasing" peaks relative to "Decreasing" peaks
# Produces:
#  - Increasing vs Decreasing
runDreme(sequences_by_response$Increasing, control = sequences_by_response$Decreasing)

# Use the "Static" response category as the control set to discover motifs 
# enriched in each remaining category relative to static sites,
# Produces:
#  - Increasing vs Static
#  - Decreasing vs Static
runDreme(sequences_by_response, control = "Static")

# Combine the "Static" and "Increasing" sequences and use as a background set to
# discover motifs enriched in the remaining categories relative
# Produces:
#  - Decreasing vs Static+Increasing
runDreme(sequences_by_response, control = c("Static", "Increasing"))
```

In order to discover motifs associated with dynamic changes to chromatin
accessibility, we use static sites as the control set to discover motifs
enriched in both increasing and decreasing sites.

```{r, eval=F}
dreme_vs_static <- runDreme(sequences_by_response, control = "Static")
```

```{r, echo=FALSE}
# I secretly cache this to decrease build-time of the manuscript
drake::loadd(dreme_vs_static)
```

```{r, fig.height=4, fig.width=7, echo = FALSE}
dreme_fig_top <- purrr::map(dreme_vs_static, "motif") %>% 
  purrr::map(universalmotif::view_motifs) %>% 
  purrr::imap(~{
    .x +
      ggtitle(paste(.y, "Motifs")) +
      theme(plot.title = element_text(hjust = 0.5, size = 14))
  }) %>% 
  patchwork::wrap_plots(ncol = 2) 
```
```{r, echo=FALSE}

# Require that the minimum overlap for similarity metric is equal to the
# smallest possible overlap if the shortest motif was completely contained
# within the largest motif.
get_min_overlap <- function(df){
  min(df$length) / max(df$length)
}

get_motif_correlation <- function(df, method = "PCC"){
  df$motif %>% 
    universalmotif::compare_motifs(min.overlap = get_min_overlap(df), method = method)
}

plot_correlation_heatmap <- function(mat, name){
  
  min_color <- round(min(mat) - 0.1, digits = 1)
  colors <- circlize::colorRamp2(c(min_color, 1), c("white", "dodgerblue3"))
  
  rownames(mat) <- NULL
  ComplexHeatmap::Heatmap(mat,
                          col = colors, 
                          name = "Pearson Correlation", 
                          column_names_rot = 45,
                          column_title = paste(name, "Motif Similarity")
                          )
  
}
```

```{r, fig.height=5, fig.width=10, echo = FALSE}
dreme_fig_bottom <- dreme_vs_static %>% 
  purrr::map(get_motif_correlation) %>% 
  purrr::imap(plot_correlation_heatmap) %>% 
  # capture heatmaps as grobs
  purrr::map(~{grid::grid.grabExpr(draw(.x))}) %>% 
  patchwork::wrap_plots(nrow = 1) 
```

These data are readily visualized using the `universalmotif::view_motifs`
function. Visualization of the results reveals two distinct motifs associated
with decreasing and increasing sites \ref{fig:dec_v_inc_dreme}. In this
analysis, the *de-novo* discovered motifs within each category appear visually
similar to each other, however, the MEME Suite does not provide a mechanism to
compare groups of motifs based on all pairwise similarity metrics. We utilized
the `universalmotif::compare_motifs` function to compute Pearson correlation
coefficients for each set of motifs to quantitatively assess motif similarity
\ref{fig:dec_v_inc_dreme}. 

```{r dec_v_inc_dreme, fig.height=10, fig.width=10, echo=F, fig.cap="\\label{fig:dec_v_inc_dreme}PWMs of discovered motifs in Decreasing (A) and Increasing (B) sites. C,D Pearson correlation heatmaps comparing similarity of Decreasing (C) and Increasing (D) motifs."}
patchwork::wrap_plots(dreme_fig_top, dreme_fig_bottom, ncol = 1) +
  patchwork::plot_annotation(tag_levels = "A")
```
Transcription factors often bind with sequence specificity to regulate activity
of nearby genomic elements. Therefore, comparison of *de-novo* motifs with known
DNA binding motifs for transcription factors can be a key step in identifying
regulators of genomic elements. The TomTom tool is used to compare unknown
motifs against a list of known motifs to identify matches, `memes` provides the
`runTomTom` function as an interface to this tool. By passing the results from
`runDreme` into `runTomTom` and searching within a database of *Drosophila* transcription
factor motifs, we can identify candidate transcription factors which may bind
the motifs associated with increasing and decreasing chromatin accessibility.

```{r}
dreme_vs_static_tomtom <- runTomTom(dreme_vs_static, database = "data/flyFactorSurveyCleaned.meme", dist = "ed")
```
Using this approach, the results can be visualized using 
the `view_tomtom_hits()` function to visually inspect the matches
assigned by TomTom, providing a simple way to assess the quality of the match. 
A representative plot of these data is shown in \ref{fig:tomtom_example}, while
the full results can be viewed in \ref{tab:tomtom_table}. We
uncover that the motifs associated with decreasing sites are highly similar to
the E93 motif. Conversely, motifs found in increasing sites match the
transcription factors br, l(3)neo38, gl, and lola \ref{tab:tomtom_table}. These
data support the hypothesis that E93 binding to its motif may play a larger role
in chromatin closing activity, while binding of the transcription factor br is
associated with chromatin opening.
```{r tomtom_example, echo = F, fig.height=3, fig.width=7.5, fig.cap="\\label{fig:tomtom_example}Representative plots generated by view_tomtom_hits showing the top hit for motifs discovered in decreasing (A) and increasing (B) peaks."}
plot_top_hit <- function(x){
  x %>% 
    view_tomtom_hits(1)
}

top_hit_grid <- function(x, title){
  x %>% 
    patchwork::wrap_plots(nrow = 1)
}

# Plotting every hit:
# decided to just use a representative sample insted
#dreme_vs_static_tomtom %>% 
#  purrr::imap(~{plot_top_hit(.x) %>% top_hit_grid(., .y)}) %>% 
#  patchwork::wrap_plots(ncol = 1)

dreme_vs_static_tomtom %>% 
  purrr::imap(~{
    .x %>% 
      dplyr::mutate(name = paste0(.y, " ", name)) %>% 
      update_motifs() %>% 
      plot_top_hit() %>% 
      .[[2]]
    }) %>% 
  patchwork::wrap_plots() +
    patchwork::plot_annotation(tag_levels = "A")
```
```{r, echo=F}
library(gt)

dreme_vs_static_tomtom %>% 
  dplyr::bind_rows(.id = "category") %>% 
  dplyr::mutate(category = paste(category, "Motifs")) %>% 
  dplyr::arrange(category, rank) %>% 
  dplyr::select(category, name, best_match_altname) %>% 
  dplyr::rename("Best Match TF" = best_match_altname) %>% 
  gt(rowname_col = "name",
     groupname_col = "category")
     # this feature is in development branch??
     # search SO: gt table reference
     #lab = "tab:tomtom_table") 
  
  
```



## Motif enrichment testing using runAme

Discovery and matching of *de-novo* motifs is only one way to find candidate
transcription factors within target sites. Indeed, in many instances, requiring
that a motif is recovered *de-novo* is not ideal, as these approaches are
"discovery based" as opposed to hypothesis driven. Another approach, implemented
by the AME tool, is to search for known motif instances in target sequences and
test for their overrepresentation relative to a background set of sequences
\cite{ame}. The `runAme()` function is the `memes` interface to the AME tool. It
accepts a set of sequences as input an control sets, and will peform enrichment
testing using a provided motif database for occurrances of each provided motif.

A major limitation of this approach is that transcription factors containing
similar families of DNA binding domain often possess highly similar motifs,
making it difficult to identify the "true" binding factor associated with an
overrepresented motif. Additionally, when searching for matches against a motif
database, AME must account for multiple testing, therefore using a larger than
necessary motif database can produce a large multiple testing penalty, limiting
sensitivity of detection. One way to overcome these limitations is to limit the
transcription factor motif database to include only motifs for transcription
factors expressed in the sample of interest. Accounting for transcription factor
expression during motif analysis has been demonstrated to increase the
probability of identifying biologically relevant transcription factor candidates
\cite{hector franco's STAR paper, others?}.

The `memes` universalmotif data.frame structure can be used to integrate
expression data with a motif database to remove entries for transcription
factors which are not expressed. To do so, we import a *Drosophila*
transcription factor motif database generated by the Fly Factor Survey and
convert to universalmotif data.frame format \cite{fly factor}. In this database,
the `altname` column stores the gene symbol.

```{r}
fly_factor <- universalmotif::read_meme("data/flyFactorSurveyCleaned.meme") %>% 
  as_universalmotif_dataframe()
```
```{r, echo = FALSE}
head(fly_factor, 3)
```
Next, we import a pre-filtered list of genes expressed in a timecourse of
**Drosophila** wing development.
```{r}
wing_expressed_genes <- read.csv("data/wing_expressed_genes.csv")
```

```{r, echo = FALSE}
n_fly_factor_expressed <- fly_factor %>% 
  dplyr::filter((altname %in% wing_expressed_genes$symbol)) %>% 
  nrow()
n_fly_factor_unexpressed <- fly_factor %>% 
  dplyr::filter(!(altname %in% wing_expressed_genes$symbol)) %>% 
  nrow()
```

Finally, we subset the motif database to only expressed genes using `dplyr`
data.frame subsetting syntax (note that base R subsetting functions operate
equally well on these data structures), then convert the data.frame back into
`universalmotif` format using `as_universalmotif`. This filtering step removes
`r (n_fly_factor_unexpressed / nrow(fly_factor)) %>% {. * 100} %>% round()`% of
entries from the original database, greatly reducing the multiple-testing
correction.

```{r}
fly_factor_expressed <- fly_factor %>% 
  dplyr::filter(altname %in% wing_expressed_genes$symbol) %>% 
  as_universalmotif()
```

`runAme` syntax is identical to `runDreme` in that discriminative designs can be
constructed by calling list entries by name. Data can be visualized using
`ame_plot_heatmap()`, revealing that the E93 motif is strongly enriched at
Decreasing sites, while l(3)neo38, lola, and br are enriched in Increasing
sites, supporting the *de-novo* discovery results \ref{fig:ame_heatmap}.
Additionally, AME detects several other transcription factor motifs which
distinguish decreasing and increasing sites, providing additional clues to
potential factors which also bind E93 ChIP peaks to affect chromatin
accessibility.
```{r}
ame_vs_static <- runAme(sequences_by_response, control = "Static", database = fly_factor_expressed)
```

```{r ame_heatmap, fig.height=3, fig.width=7.5, echo = FALSE, fig.cap="\\label{fig:ame_heatmap} A heatmap of the -log10(adj.pvalues) from AME enrichment testing within increasing and decreasing sites."}
ame_vs_static %>% 
  dplyr::bind_rows(.id = "category") %>% 
  dplyr::mutate(category = paste0(category, "\nAccessibility")) %>% 
  dplyr::group_by(category, motif_alt_id) %>% 
  dplyr::filter(adj.pvalue == min(adj.pvalue)) %>% 
  ame_plot_heatmap(group = category, id = motif_alt_id) +
    labs(x = "Transcription Factor",
         y = "ChIP Peak Type")
```
### Motif matching using runFimo

A striking result from these analysis is that the E93 motif is so strongly
enriched within E93 ChIP peaks which decrease in accessibility. Significance of
motif enrichment can be driven by several factors, such as quality of the query
motif relative to the canonical motif or differences in motif number in one
group relative to other groups. These questions can be explored directly by
identifying motif occurrances in target regions and examining their properties.
FIMO allows users to match motifs in input sequences while returning information
about the quality of each match in the form of a quantitative score \cite{fimo}. 

In order to examine the properties of the E93 motif between different ChIP
peaks, we scan all E93 ChIP peaks for matches to the Fly Factor Survey E93 motif
using `runFimo`. Results are returned as a GRanges object containing the
positions of each motif. Setting `skip_matched_sequence` to `FALSE` adds the
sequence of the detected motif to the output.

```{r}
e93_fimo <- runFimo(all_sequences, fly_factor_expressed$Eip93F_SANGER_10, skip_matched_sequence = FALSE, thresh = 1e-3)
```

Using `plyranges`, matched motifs can be joined with the metadata of the ChIP peaks with which they intersect.
```{r}
e93_fimo %<>% 
  plyranges::join_overlap_intersect(chip_results)
```

```{r, echo=F}
e93_stack <- e93_fimo %>% 
  data.frame %>%  
  split(.$e93_chromatin_response) %>% 
  purrr::imap(~{
    universalmotif::create_motif(.x$matched_sequence, name = paste(.y, "E93"))
  }) %>% 
  rev %>% 
  {
    m <- .
    e93_flyfactor <- fly_factor_expressed$Eip93F_SANGER_10
    e93_flyfactor@name <- "E93 FlyFactorSurvey"
    
    m$e93 <- e93_flyfactor
    return(m)
  } %>% 
  rev %>% 
  universalmotif::view_motifs()
```
```{r, echo=F}
n_motifs <- chip_results %>% 
  plyranges::mutate(has_match = ifelse(. %over% e93_fimo, "Match", "No Match")) %>% 
  data.frame %>% 
  ggplot(aes(e93_chromatin_response)) +
    geom_bar(aes(fill = forcats::fct_rev(has_match)), position = "fill") +
     scale_fill_manual(values = c("Match" = "firebrick",
                                  "No Match" = "Black")) +
     labs(fill = "E93 Motif Match",
          y = "Fraction of Sites",
          x = "Response to E93 binding") 
```
```{r, fig.height=5, fig.width=3, echo=F}
motif_quality <- e93_fimo %>% 
  data.frame %>% 
  ggplot(aes(e93_chromatin_response, score)) +
    geom_boxplot(aes(fill = e93_chromatin_response), notch = TRUE) +
    theme_bw() +
    labs(y = "FIMO Score",
         x = "Chromatin Response in E93 ChIP Peak") +
    theme(legend.position = "none")
```

Using this approach we can deeply examine the properties of the E93 motif within
each chromatin response category. First, by counting the number of E93 motifs
within each category, we demonstrate that Decreasing sites are more likely than
increasing or static sites to contain an E93 motif \ref{fig:fimo}A. We extend
these observations by rederiving position-weight matrices from sequences
matching the E93 motif within each category, allowing visual inspection of motif
quality across groups \ref{fig:fimo}B. Notably, differences in quality at base
positions 8-12 appear to distinguish increasing from decreasing motifs, where
decreasing motifs are more likely to have strong A bases at positions 8 and 9,
while E93 motifs from increasing sites are more likely to have a T base pair at
position 12 \ref{fig:fimo}B. Examination of bulk FIMO scores (where higher
scores represent motifs more similar to the reference) also reveals differences
in E93 motif quality between groups, in particular, E93 motifs from Decreasing
sites have higher scores \ref{fig:fimo}C. Together, these data demonstrate that
a key distinguishing factor between whether a sites will decrease or increase in
chromatin accessibility following E93 binding is the number and quality of E93
motifs at that site. 

In summary, `memes` establishes a powerful motif analysis environment by
leveraging the speed and utility of the MEME Suite set of tools in conjunction
with the flexible and extensive R/Bioconductor package landscape.
```{r fimo, fig.width=7.5, fig.height=9, fig.cap="\\label{fig:fimo}A. Stacked barplot showing fraction of each chromatin response category containing E93 motif matches. B. PWMs generated from E93 motif sequences detected in each chromatin response category. C. Boxplot of FIMO Score for each E93 motif within each chromatin response category. Outliers are plotted as distinct points."}
#patchwork::wrap_plots(n_motifs, motif_quality, patchwork::guide_area(), e93_stack, widths = c(0.2, 0.3, 0.5))
patchwork::wrap_plots(n_motifs, patchwork::guide_area(), 
                      e93_stack, motif_quality, 
                      ncol = 2, widths = c(0.6, 0.4),
                      guides = 'collect') +
    patchwork::plot_annotation(tag_levels = "A")
```

# Availability and Future developments:

The `memes` package source code and installation instructions are available on
github: [github.com/snystrom/memes](github.com/snystrom/memes). Documentation is
stored in the package vignettes, and also available at the package website:
[snystrom.github.io/memes](snystrom.github.io/memes). The `memes_docker`
containers are available from DockerHub
[https://hub.docker.com/r/snystrom/memes_docker](https://hub.docker.com/r/snystrom/memes_docker),
and their source code is hosted at github:
[https://github.com/snystrom/memes_docker](https://github.com/snystrom/memes_docker).

This manuscript was automatically generated using Rmarkdown within the
`memes_docker` container (TODO: ADD VERSION). Its source code, raw data, and
instructions to reproduce all analysis can be found at
[github.com/snystrom/memes_paper/](github.com/snystrom/memes_paper/).

In the future we hope to add additional data visualizations for examining motif
positioning within features. We will continue to add support for additional MEME Suite
tools in future versions of the package. Finally, we hope to improve the `memes`
tooling for analyzing amino-acid motifs, which although fully supported by our
current framework, may require extra tools which we have not considered.

# Acknowledgements
We would like to acknowledge Megan Justice, and members of the McKay lab for
helpful comments and feedback.
